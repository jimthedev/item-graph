Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _templateObject = _taggedTemplateLiteral(['', ''], ['', '']);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphqlTag = require('graphql-tag');

var _graphqlTag2 = _interopRequireDefault(_graphqlTag);

var _babylon = require('babylon');

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var filterFn = function filterFn(line) {
	return !(line[0] === '#' && line.slice(1).split(' ')[0] === 'import') && !(line === '');
};

var stripImports = function stripImports(source) {
	return source.split('\n').filter(filterFn).join('\n');
};

var expandImports = function expandImports(source, resolvePath, reference) {
	reference = _path2.default.dirname(reference);
	var queryAST = (0, _graphqlTag2.default)(_templateObject, stripImports(source));
	var lines = source.split('\n');
	var defs = queryAST.definitions;
	lines.some(function (line) {
		if (line[0] === '#' && line.slice(1).split(' ')[0] === 'import') {
			var importFile = line.slice(1).split(' ')[1].slice(1, -1);
			var fragmentAST = (0, _graphqlTag2.default)(_templateObject, _helper2.default.getContents(importFile, _path2.default.resolve(reference, resolvePath)));
			defs = [].concat(_toConsumableArray(defs), _toConsumableArray(fragmentAST.definitions));
		}
		return line.length !== 0 && line[0] !== '#';
	});
	return _extends({}, queryAST, { definitions: defs });
};

exports.default = function (_ref) {
	var t = _ref.types;
	return {
		visitor: {
			ImportDeclaration: {
				exit: function exit(path, state) {
					var shouldBeInlined = _helper2.default.shouldBeInlined,
					    hasRoot = _helper2.default.hasRoot,
					    transformRelativeToRootPath = _helper2.default.transformRelativeToRootPath,
					    getContents = _helper2.default.getContents;


					var givenPath = path.node.source.value;
					var reference = state && state.file && state.file.opts.filename;
					var extensions = state && state.opts && state.opts.extensions;

					if (_helper2.default.shouldBeInlined(givenPath, extensions)) {
						if (path.node.specifiers.length > 1) {
							throw new Error('Destructuring inlined import is not allowed. Check the import statement for \'' + givenPath + '\'');
						}

						// Here we detect the use of Meteor by checking global.meteorBabelHelpers
						if (global.meteorBabelHelpers && hasRoot(reference)) {
							reference = transformRelativeToRootPath(reference);
						}

						var content = getContents(givenPath, reference);
						var graphqlAST = expandImports(content, givenPath, reference);
						var babelAST = (0, _babylon.parse)('const obj = ' + JSON.stringify(graphqlAST));
						var objExp = babelAST.program.body[0].declarations[0].init;
						var variable = t.variableDeclarator(t.identifier(path.node.specifiers[0].local.name), t.objectExpression(objExp.properties));

						path.replaceWith(t.variableDeclaration('const', [variable]));
					}
				}
			}
		}
	};
};